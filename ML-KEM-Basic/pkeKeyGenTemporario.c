#include <stdio.h>
#include <stdbool.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "amostragem.h"
#include "auxiliares.h"
#include "ntt.h"
#include "parametros.h"
#include "pkeKeyGen.h"
#include "fips202.h"
#include <openssl/sha.h>
#include <openssl/evp.h>

/*************************************************************************
Teste da imnplementação do Algoritmo 12 - KeyGen() -  ML-KEM FIPS 203 ipd
Generates an encryption key and a corresponding decryption key.
Output: encryption key ekPKE ∈ B^384k+32.
Output: decryption key dkPKE ∈ B^384k. 
**************************************************************************/

void calculaT_hat(const uint16_t (*A)[KYBER_K][KYBER_N], const uint16_t s[KYBER_K][KYBER_N], const uint16_t e[KYBER_K][KYBER_N], uint16_t t_hat[KYBER_K][KYBER_N]) {
    uint16_t tempResultado[KYBER_K][KYBER_N] = {{0}};      

    for (int i = 0; i < KYBER_K; ++i) {
        for (int k = 0; k < KYBER_K; ++k) {
            uint16_t tempMultiplicacao[KYBER_N] = {0}; 
            multiplicaNTT(A[i][k], s[k], tempMultiplicacao); 

            // Adiciona tempMultiplicacao ao tempResultado[i], com redução modular
            for (int n = 0; n < KYBER_N; ++n) {
                tempResultado[i][n] = (tempResultado[i][n] + tempMultiplicacao[n]) % KYBER_Q;
            }
        }
    }

    // Adiciona "e" a tempResultado para obter t_hat com redução modular
    for (int i = 0; i < KYBER_K; ++i) {
        for (int n = 0; n < KYBER_N; ++n) {
            t_hat[i][n] = (tempResultado[i][n] + e[i][n]) % KYBER_Q;
        }
    }
}

void exibeVetorPolinomios(uint16_t vetor[2][256], char* nomeVetor){
    printf("\n Vetor %s : ", nomeVetor);
    for (int i = 0; i < KYBER_K; i++)
    {
        for (int j = 0; j < KYBER_N; j++)
        {
            printf("%d ,",vetor[i][j]);
        }
        printf("\n");
    }
    
}

void exibeMatrizA(uint16_t (*A)[KYBER_K][KYBER_N]) {
    printf("\n A : ");
    for (int i = 0; i < KYBER_K; i++)    {
        for (int j = 0; j < KYBER_K; j++)  {
            for (int k = 0; k < KYBER_N; k++)  {
                printf("%hu ",A[i][j][k]);
            }
            printf("\n");
            
        }        
    }
    printf("\n");
}

void verificaCalculoT(uint16_t t1[2][256],uint16_t t2[2][256]) {
     if((memcmp(t1[0],t2[0],sizeof(t1[0]))==0) && (memcmp(t1[1],t2[1],sizeof(t1[1]))==0)) {
        printf("\n\n Vetor t foi calculado corretamente!!!! \n");
    }
    else {
        printf("\n\n Falha no cálculo do vetor t \n");
    }
}

void exibeChaves(chavesPKE chaves) {
    printf("Chaves \n chave pública : ");
    for (int i = 0; i < sizeof(chaves.ek)/sizeof(chaves.ek[0]); i++)
    {
        printf("%02x", chaves.ek[i]);
    }
    printf("\n \nchave privada : ");
    for (int i = 0; i < sizeof(chaves.dk)/sizeof(chaves.dk[0]); i++)
    {
        printf("%02x", chaves.dk[i]);
    }
}
void exibeByte32(uint8_t rhoSigma[32], char* texto) {
    printf("\n %s : ", texto);
    for (int i = 0; i < 32; i++) {
        printf(" %02x", rhoSigma[i]);
    }    
    printf("\n");
}

// Função para comparar arrays genéricos de uint16_t
bool compareArrays(const uint16_t *array1, const uint16_t *array2, size_t numElements) {
    for (size_t i = 0; i < numElements; i++) {
        if (array1[i] != array2[i]) {
            printf("\n elemento[%d] => %d  x  %d", i,array1[i],array2[i]);
            return false; // Retorna falso assim que encontrar um elemento diferente
        }
    }
    return true; // Todos os elementos são iguais
}

// Função para comparar matrizes de uint16_t
bool compareMatrizes(const uint16_t matriz1[KYBER_K][KYBER_K][KYBER_N], const uint16_t matriz2[KYBER_K][KYBER_K][KYBER_N]) {
    for (size_t i = 0; i < KYBER_K; i++) {
        for (size_t j = 0; j < KYBER_K; j++) {
            for (size_t k = 0; k < KYBER_N; k++) {
                if (matriz1[i][j][k] != matriz2[i][j][k]) {
                    printf("\n elementos[%d][%d][%d] diferem => matriz1: %zu  x  matriz2 : %zu", i,j,k,matriz1[i][j][k],matriz2[i][j][k]);
                    return false; // Retorna falso assim que encontrar um elemento diferente
                }
            }
        }
    }
    return true; // Todos os elementos são iguais
}
// Função para comparar matrizes de uint16_t
bool compareVetorPoly(const uint16_t matriz1[KYBER_K][KYBER_N], const uint16_t matriz2[KYBER_K][KYBER_N]) {
    for (size_t i = 0; i < KYBER_K; i++) {
        for (size_t j = 0; j < KYBER_N; j++) {            
                if (matriz1[i][j] != matriz2[i][j]) {
                    printf("\n elementos[%d][%d] diferem => matriz1: %zu  x  matriz2 : %zu", i,j,matriz1[i][j],matriz2[i][j]);
                    return false; // Retorna falso assim que encontrar um elemento diferente
                }            
        }
    }
    return true; // Todos os elementos são iguais
}

// início da função de Geração de Chaves
chavesPKE pkeKeyGen() {
    
    //unsigned char d[32];                          // Array para armazenar os 32 bytes aleatórios  
    unsigned char d[32] = {0xcf, 0xc0, 0xd0, 0xb6, 0x21, 0x8a, 0x41, 0x72, 0x5a, 0x5d, 0xe7, 0xf3, 0xea, 0xe1, 0x1d, 0xd8, 0x8b, 0x6e, 0x5b, 0x16, 0x61, 0xba, 0xcf, 0xca, 0x47, 0x29, 0xf5, 0x4e, 0x6f, 0x57, 0x8b, 0x03};
    unsigned char rho[32], sigma[32];            // saídas de G
    chavesPKE chaves = {0};   
    unsigned char output[64 * KYBER_ETA1] = {0};    // Bytes aleatórios para SamplePolyCBD

    uint8_t N = 0;        
    uint16_t f[KYBER_N] = {0};
    
    // Alocação dinâmica da matriz A
    
    uint16_t (*A)[KYBER_K][KYBER_N] = malloc(KYBER_K * KYBER_K * KYBER_N * sizeof(uint16_t));

    if (A == NULL) {
        fprintf(stderr, "Falha na alocação de memória\n");
        //return EXIT_FAILURE;
    }

    // Inicialização (opcional mas recomendada)
    for (int i = 0; i < KYBER_K; i++) {
        for (int j = 0; j < KYBER_K; j++) {
            for (int k = 0; k < KYBER_N; k++) {
                A[i][j][k] = 0; // Inicialize conforme necessário
            }
        }
    }
    
    uint16_t s[KYBER_K][KYBER_N] = {{0}};
    uint16_t e[KYBER_K][KYBER_N] = {{0}};
    uint16_t t_IETF[KYBER_K][KYBER_N] = { 
        {696, 1625, 2551, 1721, 1656, 2481, 930, 903, 3256, 3247, 2120, 1406, 218, 2136, 2209, 2672, 1601, 1686, 706, 1478, 357, 1194, 2376, 727, 126, 1004, 1518, 160, 2239, 3148, 2129, 3298, 1299, 1804, 2614, 852, 1628, 1989, 1833, 129, 2928, 862, 2261, 2283, 1605, 334, 82, 3158, 1458, 1765, 1272, 168, 430, 1437, 1180, 2935, 1272, 2466, 88, 372, 2630, 2463, 1274, 316, 596, 2017, 1054, 1414, 2338, 1095, 2577, 2789, 236, 2886, 561, 2704, 1359, 1181, 216, 231, 1247, 2933, 2070, 17, 1039, 62, 2515, 433, 929, 3310, 2657, 1106, 2785, 1038, 1174, 314, 1048, 689, 1668, 1867, 1436, 1352, 2791, 2515, 596, 3118, 1450, 3237, 1344, 1071, 975, 2043, 1031, 1005, 317, 159, 1274, 47, 2555, 2112, 1849, 1437, 1878, 331, 535, 980, 449, 1430, 2064, 1025, 1028, 573, 2854, 836, 1452, 60, 2949, 963, 44, 2147, 1953, 2844, 1896, 3150, 3321, 2653, 2634, 2071, 1451, 3155, 3154, 1375, 1121, 2745, 2539, 3107, 374, 832, 2575, 401, 506, 1132, 1637, 699, 384, 41, 1379, 693, 1395, 1594, 1212, 0, 1702, 1408, 921, 799, 1724, 858, 3220, 897, 2322, 1187, 2276, 470, 1837, 3293, 1724, 1530, 1709, 2010, 99, 269, 2862, 2411, 421, 353, 1372, 1508, 338, 2118, 2068, 2688, 1608, 1735, 2627, 3147, 1986, 2309, 96, 537, 1819, 1087, 925, 1616, 1318, 1987, 1442, 2568, 1518, 845, 1639, 1546, 1774, 2309, 2068, 679, 2085, 2630, 1850, 2743, 1941, 963, 2773, 3126, 249, 730, 80, 1799, 2769, 1688, 2623, 4, 1427, 2935, 201, 3187, 2869, 3214, 724, 224, 2798, 3305, 17, 2110, 506, 111},
        {341, 2365, 2517, 349, 3079, 2841, 1007, 3211, 16, 368, 1424, 685, 568, 2606, 2459, 938, 3136, 2289, 1958, 2340, 2333, 2357, 2670, 2594, 476, 582, 1599, 217, 3149, 974, 3258, 961, 1508, 1616, 150, 3270, 1183, 3239, 374, 2411, 1028, 3217, 2174, 1174, 3287, 2236, 2373, 1959, 2359, 2060, 1720, 1629, 1243, 2941, 2041, 1520, 2277, 1328, 443, 2922, 1011, 1998, 1311, 1964, 2685, 2376, 528, 550, 167, 2885, 657, 3216, 537, 3068, 2561, 3102, 2169, 461, 2185, 1844, 220, 1627, 828, 2613, 1231, 484, 3104, 480, 24, 2434, 2367, 1091, 465, 389, 2494, 3196, 772, 1944, 2762, 3176, 930, 813, 676, 1370, 2695, 1641, 2928, 1782, 1010, 243, 1956, 63, 251, 727, 2814, 2263, 1906, 2167, 495, 2296, 1734, 536, 324, 598, 1022, 1560, 1597, 2350, 3160, 199, 248, 1339, 740, 1201, 1185, 437, 1512, 2312, 1775, 721, 1296, 164, 2544, 739, 296, 2496, 689, 2298, 892, 2987, 3323, 1166, 83, 1572, 2268, 1058, 2553, 3040, 3217, 522, 1511, 833, 1383, 1634, 2516, 474, 25, 2219, 1054, 2458, 1933, 2390, 1260, 2763, 2036, 2206, 3199, 72, 2162, 2905, 159, 2175, 1706, 2525, 1249, 854, 1112, 1813, 2902, 3327, 600, 2840, 582, 870, 3036, 748, 2595, 2547, 1640, 3061, 2356, 1244, 1377, 2525, 269, 1151, 3252, 1125, 2321, 231, 2849, 917, 2366, 1108, 2694, 1419, 2158, 1173, 1054, 217, 815, 1737, 2265, 2468, 669, 1791, 642, 2233, 1443, 1918, 2532, 752, 899, 436, 3036, 372, 2768, 2126, 3075, 1324, 159, 3075, 2900, 2457, 2559, 2624, 162, 319, 1592, 1733, 446, 513, 99, 2967, 2991, 1499}
    };

    //Conjunto de arrays gerados com a implementação do IETF para teste
    uint16_t A_linha[KYBER_K][KYBER_K][KYBER_N] = {
    {
        {472, 1448, 2697, 636, 2966, 2591, 31, 78, 1006, 2069, 398, 3010, 2283, 99, 1234, 1874, 1981, 1240, 54, 3213, 1293, 1157, 165, 6, 168, 2854, 334, 2489, 2380, 1519, 3278, 2614, 1322, 431, 2166, 2135, 477, 2160, 2601, 1529, 1283, 1017, 809, 390, 149, 1672, 2186, 2362, 3039, 2656, 1955, 3112, 799, 2441, 2818, 1758, 2691, 2118, 2304, 2362, 873, 3192, 1380, 1697, 440, 2947, 2814, 2185, 512, 3155, 1664, 2554, 3296, 2625, 1255, 1428, 661, 2805, 1897, 2789, 984, 2206, 2015, 2496, 866, 1170, 570, 1382, 1862, 3306, 139, 383, 1275, 68, 2587, 258, 232, 1293, 1636, 680, 1630, 2253, 621, 1260, 1360, 1016, 964, 2769, 861, 1568, 2802, 1696, 1410, 1587, 3195, 2709, 2653, 865, 569, 2716, 79, 1972, 3188, 2539, 1540, 964, 1676, 1129, 1647, 3133, 1508, 2191, 2835, 352, 3039, 306, 1113, 3018, 1824, 765, 1706, 1639, 9, 1015, 2084, 2117, 669, 1728, 1275, 849, 1792, 1296, 371, 879, 1964, 41, 3153, 1771, 930, 1512, 82, 3081, 1174, 1046, 2555, 1373, 1685, 685, 1419, 3136, 1549, 341, 2372, 634, 457, 3020, 78, 1504, 359, 1134, 943, 2361, 1784, 1100, 94, 630, 2401, 2086, 2879, 3295, 2727, 875, 3056, 115, 1012, 1936, 3069, 2032, 1006, 2278, 1530, 3030, 62, 2013, 187, 214, 815, 2033, 503, 2861, 2210, 390, 207, 981, 2664, 454, 2401, 685, 1307, 241, 1648, 294, 329, 1476, 2078, 1463, 2459, 3166, 3002, 1152, 182, 230, 1281, 928, 1182, 2046, 1151, 1927, 914, 2032, 2611, 2544, 1351, 816, 2812, 1329, 2216, 632, 142, 2983, 2143, 1202, 1858, 286, 1746, 2840}, 
        {1311, 2083, 2046, 1783, 442, 898, 2906, 2050, 3284, 2298, 1493, 1087, 2524, 1621, 1766, 1476, 1296, 3131, 2165, 3011, 1425, 909, 59, 1157, 117, 968, 121, 951, 961, 2825, 3324, 985, 1002, 1823, 2892, 2731, 2040, 2787, 3123, 203, 476, 590, 2550, 813, 2459, 421, 2563, 3325, 1717, 499, 1938, 2471, 1339, 904, 1331, 2300, 1582, 1724, 2232, 2665, 1044, 1460, 1734, 3027, 2777, 166, 1256, 1997, 2056, 3265, 2665, 916, 1924, 390, 165, 362, 1825, 2105, 1617, 651, 645, 2778, 2039, 2068, 86, 276, 468, 1224, 3015, 697, 2043, 1461, 825, 843, 300, 3079, 1795, 922, 2456, 11, 437, 2375, 2827, 1741, 75, 2196, 2119, 3253, 170, 253, 143, 2358, 1538, 3239, 1545, 1406, 2589, 1309, 1561, 1446, 1519, 2083, 466, 932, 3078, 2428, 60, 3130, 1124, 2841, 3216, 2714, 1851, 2217, 3183, 459, 1264, 1172, 99, 956, 767, 1245, 2290, 1843, 208, 1575, 924, 1313, 1535, 828, 3237, 681, 3300, 2322, 1550, 2950, 693, 646, 1580, 3216, 953, 2882, 1532, 3008, 2413, 2412, 704, 128, 280, 1335, 299, 982, 2467, 1511, 2958, 2599, 1860, 2391, 163, 992, 2717, 927, 1179, 67, 2549, 1111, 3290, 1445, 2544, 278, 2440, 1971, 861, 3145, 3256, 1491, 1171, 1715, 849, 3182, 2782, 1108, 3073, 2005, 2147, 34, 146, 404, 3275, 1939, 461, 1326, 2598, 3005, 3123, 264, 292, 2515, 2524, 2048, 1578, 2017, 1248, 2846, 22, 1173, 1060, 49, 1634, 1641, 2907, 2413, 2704, 842, 1475, 2428, 2418, 2737, 657, 2371, 1240, 832, 983, 3227, 2836, 2469, 198, 3112, 232, 1600, 2369, 1583, 2144, 1146, 2763, 2244}
    }, 
    {
        {2763, 581, 1733, 2878, 1715, 636, 82, 2156, 2128, 1956, 1755, 247, 3058, 1859, 2254, 2873, 617, 288, 224, 767, 1877, 408, 2903, 2644, 3270, 1133, 2090, 845, 1011, 665, 1823, 2474, 402, 66, 1221, 2151, 853, 3256, 1645, 290, 1835, 2618, 640, 235, 1437, 236, 1249, 971, 1170, 97, 2331, 2442, 2987, 166, 1294, 782, 2505, 2299, 1921, 1133, 2146, 2643, 491, 653, 848, 2284, 2372, 346, 1027, 407, 2149, 2355, 3121, 769, 713, 2795, 1959, 1162, 2627, 326, 754, 2029, 1977, 670, 1675, 2244, 2990, 1943, 2978, 2512, 1436, 1258, 1659, 3069, 227, 3002, 2172, 2764, 2229, 2247, 916, 1644, 1358, 1352, 2262, 384, 637, 1435, 1726, 3012, 2109, 3281, 144, 2634, 1487, 963, 3159, 70, 2886, 1985, 376, 2409, 1415, 3172, 1613, 584, 433, 2882, 1184, 2195, 118, 1698, 2861, 1066, 2248, 3175, 1580, 994, 1731, 1902, 1499, 2602, 2576, 2104, 1756, 2337, 2874, 1088, 2237, 506, 2842, 158, 3268, 2660, 1645, 1088, 1503, 1476, 972, 78, 1368, 2528, 73, 2262, 2273, 2755, 218, 3113, 2286, 3273, 2418, 464, 1262, 749, 3200, 1257, 2010, 2433, 1764, 697, 769, 2186, 1713, 730, 1030, 931, 3254, 2508, 3141, 1310, 1570, 1418, 1878, 1376, 421, 118, 914, 2237, 139, 1749, 11, 390, 2371, 3055, 472, 2231, 3108, 1412, 882, 3250, 282, 198, 3233, 945, 2165, 1783, 1579, 1420, 2472, 2095, 2495, 2066, 3116, 1994, 2388, 1811, 371, 279, 759, 334, 1313, 2197, 1542, 1137, 1694, 1933, 339, 1159, 1790, 1924, 834, 1409, 2399, 2988, 3286, 2142, 3145, 2949, 2881, 2108, 904, 1859, 3069, 3067, 333, 2189}, 
        {162, 1606, 782, 1138, 65, 758, 201, 2207, 432, 2708, 1158, 3068, 3143, 2708, 1389, 1714, 3096, 3266, 288, 262, 1115, 1457, 580, 2864, 316, 1649, 2183, 2977, 595, 835, 2381, 999, 421, 3101, 3066, 1018, 3170, 2201, 2459, 1205, 1386, 46, 834, 3188, 426, 1660, 1278, 2233, 2395, 705, 2829, 1528, 453, 1717, 3235, 104, 1012, 1606, 1207, 565, 3230, 1921, 1791, 1709, 90, 2025, 304, 1379, 2043, 329, 2589, 267, 3241, 1434, 1780, 2068, 2297, 2268, 377, 2499, 1116, 154, 3237, 462, 1813, 464, 1678, 963, 1114, 825, 1521, 3249, 2005, 1918, 1793, 2562, 1971, 2447, 539, 2333, 1473, 2353, 1637, 173, 1692, 565, 3067, 2460, 1059, 865, 1162, 1163, 2407, 73, 192, 1516, 380, 1487, 2667, 1743, 583, 1274, 1092, 770, 1948, 452, 2187, 2843, 2527, 3162, 2376, 515, 457, 2731, 3028, 2715, 2483, 2989, 1424, 570, 421, 2885, 3315, 1264, 1102, 2920, 2965, 19, 2598, 1843, 906, 2458, 2667, 1902, 779, 1296, 815, 3091, 3024, 374, 2929, 960, 2793, 2915, 943, 1948, 52, 143, 1927, 2651, 3310, 628, 1800, 20, 141, 1448, 872, 2237, 668, 2198, 1944, 3299, 1581, 2246, 2740, 275, 2946, 625, 985, 2273, 3105, 2339, 2616, 3152, 2688, 2514, 2123, 678, 2575, 2547, 3073, 846, 1206, 2766, 686, 1883, 376, 556, 1343, 2232, 1206, 84, 518, 2098, 2708, 337, 1977, 1166, 98, 2042, 2965, 2672, 1750, 3199, 1694, 1224, 1018, 2201, 1626, 2268, 1612, 389, 541, 3146, 548, 718, 2571, 210, 1648, 2519, 2838, 1896, 1271, 38, 3079, 2597, 130, 47, 167, 605, 2487, 1140, 2462, 2881, 556, 1416}
    }
    };

    uint16_t s_linha[KYBER_K][KYBER_N] = {
        {3327, 3326, 3328, 1, 3328, 3327, 3328, 1, 0, 1, 3, 3328, 0, 3328, 0, 3328, 3328, 1, 3328, 2, 0, 0, 3328, 0, 3328, 2, 3328, 1, 1, 1, 1, 3328, 3327, 3, 3328, 3328, 3328, 1, 1, 3328, 1, 0, 0, 0, 3328, 2, 1, 1, 3328, 3327, 1, 0, 0, 1, 0, 1, 3328, 3328, 3327, 3327, 0, 0, 1, 0, 3327, 3328, 3328, 3328, 0, 2, 1, 2, 1, 1, 0, 3328, 1, 3328, 3328, 1, 2, 0, 3328, 1, 1, 1, 0, 1, 0, 1, 1, 2, 3328, 0, 0, 0, 3, 0, 0, 1, 3328, 0, 3328, 3328, 2, 3328, 3327, 1, 3328, 1, 1, 0, 3328, 1, 0, 3327, 0, 3328, 0, 3328, 2, 0, 3328, 3326, 1, 3328, 1, 0, 1, 0, 3328, 1, 0, 3327, 1, 1, 3327, 3326, 0, 3328, 3328, 0, 0, 0, 1, 0, 3328, 1, 0, 2, 3328, 1, 0, 1, 0, 3, 1, 3327, 0, 2, 3328, 3328, 0, 1, 1, 0, 2, 3327, 3328, 0, 1, 0, 3328, 0, 2, 0, 3328, 3327, 0, 3328, 3328, 3327, 0, 3327, 0, 1, 0, 2, 3326, 2, 1, 2, 0, 3328, 1, 0, 3328, 1, 3327, 0, 2, 3328, 3327, 3327, 3328, 0, 3328, 2, 3327, 0, 0, 3328, 3328, 0, 2, 3328, 3328, 3328, 3328, 0, 0, 2, 1, 0, 3328, 0, 3328, 2, 0, 0, 3326, 0, 1, 2, 0, 1, 3328, 0, 0, 3328, 3328, 1, 0, 3327, 3327, 1, 0, 0, 1, 3328, 3328, 3328, 0, 1, 3327, 3327},
        {1, 3327, 1, 0, 3328, 3327, 0, 1, 3327, 0, 1, 0, 3327, 0, 0, 2, 3327, 0, 1, 3328, 1, 1, 0, 2, 3328, 3328, 3328, 2, 3328, 1, 1, 3327, 0, 3, 2, 0, 0, 3328, 0, 2, 0, 0, 1, 1, 3327, 2, 0, 3328, 3326, 0, 1, 3327, 3328, 2, 0, 1, 3, 3327, 1, 2, 0, 3328, 3327, 3327, 0, 1, 3327, 0, 0, 3328, 0, 0, 0, 1, 0, 2, 3328, 0, 0, 3328, 3327, 2, 2, 0, 0, 3327, 0, 0, 0, 1, 0, 3327, 1, 1, 3328, 1, 3328, 0, 1, 0, 3327, 0, 1, 3326, 0, 0, 0, 3328, 1, 0, 3327, 2, 1, 0, 3328, 3328, 0, 3328, 3328, 3328, 1, 0, 3328, 3328, 3328, 0, 1, 3328, 3328, 3328, 1, 1, 0, 3328, 3328, 0, 2, 1, 3328, 3328, 0, 0, 1, 0, 3328, 3328, 1, 0, 1, 0, 1, 1, 3328, 2, 0, 3327, 1, 3328, 1, 0, 1, 2, 1, 0, 0, 0, 1, 0, 1, 1, 2, 0, 3327, 3328, 1, 1, 1, 3327, 0, 3328, 1, 3328, 1, 2, 1, 3328, 0, 3328, 3328, 3327, 1, 3327, 0, 3326, 3327, 2, 0, 3327, 0, 2, 3327, 0, 3328, 1, 0, 1, 0, 0, 3327, 3328, 1, 1, 1, 1, 1, 0, 3328, 0, 2, 1, 3327, 3327, 3327, 0, 2, 2, 0, 1, 0, 0, 2, 0, 1, 1, 2, 0, 1, 3327, 0, 3327, 1, 1, 3328, 3326, 0, 1, 0, 1, 0, 0, 2, 3328, 1, 2, 0, 1}
        };

    uint16_t e_linha[KYBER_K][KYBER_N] = {
        {0, 0, 1, 3328, 1, 0, 1, 0, 3327, 2, 0, 3327, 1, 1, 0, 3327, 1, 1, 0, 2, 1, 0, 0, 0, 2, 1, 3, 1, 3328, 1, 3328, 1, 3327, 0, 2, 0, 2, 1, 0, 2, 3328, 3328, 3328, 3327, 1, 3328, 0, 3328, 1, 0, 1, 1, 0, 0, 3328, 3328, 1, 0, 3328, 1, 0, 3328, 1, 3328, 0, 3328, 2, 1, 3328, 3328, 0, 3328, 0, 1, 1, 1, 0, 1, 3328, 1, 3328, 0, 1, 1, 1, 1, 0, 1, 3, 3327, 3328, 0, 3328, 3328, 3328, 1, 0, 1, 0, 0, 0, 0, 0, 3328, 1, 1, 3, 3328, 3328, 0, 3328, 3328, 0, 3328, 0, 0, 0, 2, 0, 0, 3328, 0, 3328, 1, 1, 3328, 3328, 1, 3327, 2, 0, 3328, 3327, 3328, 3328, 3328, 1, 3328, 0, 0, 2, 0, 3328, 0, 2, 2, 1, 3328, 0, 1, 3328, 3328, 0, 1, 1, 0, 0, 1, 3328, 0, 1, 2, 0, 2, 0, 0, 0, 1, 2, 3328, 0, 3328, 3328, 0, 0, 3328, 3327, 1, 0, 3328, 0, 1, 3328, 0, 1, 1, 2, 3327, 0, 1, 1, 1, 3328, 0, 1, 0, 0, 0, 2, 3328, 3327, 3327, 1, 3328, 3328, 3328, 0, 1, 0, 1, 1, 2, 0, 0, 3327, 0, 3327, 0, 2, 0, 3328, 3328, 0, 3328, 3328, 3327, 1, 3327, 1, 3328, 3328, 1, 3327, 3327, 3328, 0, 2, 1, 0, 0, 1, 3328, 1, 1, 3328, 3328, 3328, 3328, 1, 1, 3328, 3327, 3328, 3328, 1, 1},
        {0, 3327, 1, 0, 3, 3328, 3328, 3328, 0, 0, 3328, 1, 2, 0, 3328, 0, 0, 3328, 1, 0, 1, 1, 1, 2, 3328, 0, 0, 3327, 3327, 0, 3328, 1, 3328, 0, 0, 1, 0, 0, 0, 1, 3328, 0, 2, 1, 1, 1, 2, 0, 0, 3328, 1, 3327, 0, 0, 0, 0, 0, 3328, 1, 3326, 3328, 1, 0, 1, 3328, 3328, 3327, 3327, 3328, 3328, 0, 2, 3328, 0, 3328, 0, 3328, 3328, 3328, 0, 1, 3328, 0, 1, 2, 3327, 0, 2, 1, 1, 1, 0, 2, 1, 2, 1, 0, 1, 1, 0, 3327, 1, 3328, 3327, 0, 1, 1, 1, 1, 1, 3327, 2, 3, 0, 1, 1, 1, 0, 3327, 0, 2, 0, 0, 1, 3327, 0, 0, 0, 0, 3328, 0, 2, 1, 3327, 3327, 0, 3328, 3328, 3328, 0, 0, 0, 3326, 2, 2, 1, 0, 0, 3328, 1, 0, 3327, 2, 2, 1, 3327, 2, 3328, 1, 2, 3327, 0, 2, 3328, 2, 3, 0, 1, 0, 3326, 3328, 2, 0, 3328, 3327, 2, 0, 0, 2, 3328, 3327, 2, 3328, 2, 2, 3327, 3328, 3328, 0, 0, 0, 3327, 0, 1, 2, 0, 1, 0, 0, 2, 0, 3328, 3328, 1, 3327, 1, 0, 3328, 0, 1, 2, 2, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 2, 0, 1, 3328, 1, 3328, 3328, 1, 3328, 3328, 2, 0, 3328, 1, 3328, 0, 2, 0, 0, 2, 2, 0, 3328, 3328, 0, 2, 1, 1, 0, 3, 0, 0}
        };
/*
    uint16_t t_IETF[KYBER_K][KYBER_N] = {        
        {1355, 981, 185, 1507, 2870, 1884, 2361, 2760, 1856, 3025, 2521, 3274, 1921, 2098, 3184, 2839, 637, 2915, 1775, 967, 1954, 2599, 770, 1561, 2618, 2615, 2348, 1538, 658, 1093, 445, 2446, 520, 273, 2961, 110, 2631, 3116, 2345, 359, 2861, 1306, 898, 2070, 2156, 476, 2393, 2041, 300, 3052, 1269, 27, 2650, 996, 584, 3287, 2986, 3076, 3266, 3030, 618, 2971, 723, 3023, 657, 2960, 2247, 1639, 32, 1684, 2913, 2077, 2740, 752, 1733, 2844, 2022, 2637, 861, 1007, 1546, 2, 3324, 2566, 2642, 3116, 11, 1592, 808, 1511, 398, 3238, 2417, 6, 1694, 1156, 133, 3037, 914, 1998, 3245, 359, 2037, 3164, 24, 2916, 1054, 929, 2941, 2442, 325, 935, 1286, 1953, 3317, 3042, 2399, 2029, 2088, 2676, 1746, 429, 1670, 2430, 227, 143, 3079, 2953, 729, 3035, 2206, 1571, 477, 249, 2365, 238, 3060, 1144, 2315, 2076, 1624, 2461, 61, 830, 571, 463, 1686, 146, 2946, 605, 2075, 2291, 1670, 266, 1618, 3252, 149, 813, 3182, 1387, 2867, 3282, 2434, 324, 2587, 132, 1524, 1656, 67, 1350, 2457, 2852, 2732, 2867, 1116, 441, 2196, 2171, 993, 2970, 1730, 1830, 2206, 807, 587, 2572, 2744, 795, 1139, 1302, 362, 2406, 1540, 1366, 1923, 2322, 2278, 515, 1612, 1927, 2919, 644, 1802, 2413, 2471, 5, 2273, 1928, 142, 3151, 1885, 1932, 34, 995, 2940, 65, 190, 22, 2136, 312, 2180, 592, 2685, 2758, 673, 3040, 1630, 908, 1928, 1745, 2031, 950, 862, 11, 2983, 848, 3063, 1239, 2785, 2744, 3283, 2684, 2848, 2587, 680, 763, 2152, 1090, 2230, 2955, 1587, 2246, 2654, 612, 1198, 2457},
        {1630, 1612, 2955, 2564, 3160, 1107, 929, 231, 2410, 1508, 1511, 2933, 1548, 2708, 205, 2547, 925, 2050, 3318, 2549, 391, 1534, 1471, 2106, 510, 970, 531, 2057, 2202, 536, 2745, 3080, 85, 1313, 1848, 98, 601, 2835, 1709, 1564, 1902, 653, 2484, 3254, 3294, 207, 1882, 444, 2825, 227, 2797, 2249, 578, 2739, 1559, 1157, 2335, 3195, 2883, 2585, 269, 1218, 3104, 2937, 1122, 2944, 2236, 1675, 2828, 2969, 1989, 3, 70, 1471, 687, 1263, 3282, 2062, 1843, 2724, 2477, 1534, 1903, 1771, 3077, 1467, 1821, 1538, 2923, 907, 2625, 190, 1087, 1419, 1737, 103, 671, 1268, 1578, 3257, 2439, 2748, 1069, 2188, 319, 1100, 3029, 973, 423, 1181, 2958, 2063, 3175, 1891, 2330, 2097, 1487, 2829, 2882, 2631, 2458, 896, 2636, 2994, 1293, 1675, 577, 984, 842, 2124, 2488, 1471, 2958, 2848, 2052, 3015, 86, 1125, 720, 2158, 1139, 1476, 533, 1883, 839, 3281, 2970, 1361, 2577, 586, 2389, 1519, 669, 3195, 1399, 470, 2741, 3106, 719, 338, 808, 2167, 2715, 1103, 383, 2925, 1429, 2653, 2273, 2644, 1033, 86, 119, 3253, 915, 2465, 1803, 1258, 3186, 2237, 444, 3292, 495, 10, 1060, 2326, 553, 586, 2358, 231, 2693, 148, 245, 2686, 2900, 2414, 1485, 1399, 2804, 1483, 1441, 1011, 3113, 264, 1343, 2700, 774, 1129, 1227, 1984, 621, 2751, 1255, 2712, 2500, 961, 181, 1635, 819, 2250, 796, 1403, 1026, 3271, 397, 482, 1251, 1485, 677, 1645, 1799, 1172, 2916, 556, 2466, 2795, 2551, 1493, 1780, 427, 917, 3034, 2298, 2663, 3276, 2708, 3279, 215, 1716, 1168, 420, 1128, 1609, 1100, 2258, 2957}
    }; 
*/

    uint16_t a_hat[KYBER_N] = {0}; 

    uint16_t t[KYBER_K][KYBER_N] = {{0}}; 

    unsigned char md[EVP_MAX_MD_SIZE];   // Vetor para armazenar o resultado de SHAKE128(ρ|i|j)    
  

    // Gera bytes aleatórios para semente
    //generateRandomBytes(d, sizeof(d));                  

    // Aplica a função G em d para obter rho e sigma
    G(d, sizeof(d), rho, sigma);
    printf("Função G aplicada. Gerando rho e sigma..... \n");
    exibeByte32(d,"semente geração da chave de Encriptação ");
    exibeByte32(rho,"rho ");
    exibeByte32(sigma,"sigma");
    
    // Gera os elementos da matriz A^ pertencente a (Zq256)^k*k
    for (uint8_t i=0; i < KYBER_K; i++) {                     
        for (uint8_t j=0; j < KYBER_K; j++) {              
           memset(md, 0, sizeof(md));              // Reseta o vetor md                                        
           XOF(rho, j, i, md);               
           memset(a_hat, 0, sizeof(a_hat));      // Reinicializa a_hat para garantir que seja único em cada iteração
           sampleNTT(md, a_hat);                // Preenche a_hat com os coeficientes NTT                                                        
           for (uint16_t k=0; k < KYBER_N; k++) {                         
                // Copia a_hat para a terceira dimensão da matriz A                                
                A[i][j][k] = a_hat[k];             
           }                     
        }    
    }
    printf("\n");
    exibeMatrizA(A);
    

   // Gera os elementos do vetor s
   for (int i=0; i < KYBER_K; i++)    {                      // generate s ∈ (Zq256)^k              
        PRF(KYBER_ETA1,sigma,N,output);                      
        samplePolyCBD(output, f, KYBER_ETA1);                                                                       
        for (int j=0; j<KYBER_N; j++) {            
            s[i][j] = f[j];                                 // s[i] ∈ Zq256 sampled from CBD PRF takes a parameter η ∈ {2,3}  PRFn1                     
        }
        N = N + 1;
    }
    exibeVetorPolinomios(s, "s : ");

    // Gera os elementos do vetor e
    for (int i=0; i < KYBER_K; i++)    {                      // generate e ∈ (Zq256)^k                                                                 
        PRF(KYBER_ETA1,sigma,N,output);
        samplePolyCBD(output, f, KYBER_ETA1);
        for (int j=0; j<KYBER_N; j++) {            
            e[i][j] = f[j];                                 // e[i] ∈ Zq256 sampled from CBD PRF takes a parameter η ∈ {2,3}  PRFn1                     
        }
        N = N + 1;  
    }
    exibeVetorPolinomios(e, "e : ");


    // Transforma "s" e "e" para o domínio NTT
    for (int i=0; i < KYBER_K; i++) {        
        ntt(s[i]);                         // NTT is run k times (once for each coordinate of s)
        ntt(e[i]);                         // NTT is run k times    
    }  

    calculaT_hat(A,s,e,t);          // t = A ◦ s + e   noisy linear system in NTT domain       

    exibeVetorPolinomios(t,"t_hat"); 
    exibeVetorPolinomios(t_IETF,"t_hat_IETF"); 
    verificaCalculoT(t,t_IETF);

    // Geração das CHAVES
    for (int i=0; i < KYBER_K; i++) {         
        // Codifica t[i]                        // ▷ ByteEncode12 is run k times; include seed for Aˆ        
        byteEncode(t[i], chaves.ek + (i * 384), 12);                                              

        // Codifica s[i] para dk              chaves.dk[i] = byteEncode(s[i]);            // ▷ ByteEncode12 is run k times     
        byteEncode(s[i], chaves.dk + (i * 384), 12);
    }

    // Concatena rho ao final de ek - byteEncode(t[i])||rho;   
    memcpy(chaves.ek + (384 * KYBER_K), rho, 32);
    exibeChaves(chaves);

    return chaves; 

    // Liberar a memória alocada
    free(A);  
}

int main() {
    pkeKeyGen();        
}
