#include <stdio.h>
#include <locale.h>
#include <stdlib.h>
#include <string.h>
#include "amostragem.h"
#include "auxiliares.h"
#include "ntt.h"
#include "parametros.h"
#include "pkeKeyGen.h"
#include "pkeEncrypt.h"
#include <openssl/sha.h>
#include <openssl/evp.h>

/*******************************************************************************
Algoritmo 13 - Encrypt() -  ML-KEM FIPS 203 ipd
Uses the encryption key to encrypt a plaintext message using the randomness r.
Uses the encryption key to encrypt a plaintext message using the randomness r.
Input: encryption key ekPKE ∈ B^384k+32.
Input: message m ∈ B^32.
Input: encryption randomness r ∈ B^32.
Output: ciphertext c ∈ B^32(duk+dv)
********************************************************************************/

void calculaU(uint16_t A[KYBER_K][KYBER_K][KYBER_N], uint16_t r_hat[KYBER_K][KYBER_N], uint16_t e1[KYBER_K][KYBER_N], uint16_t u[KYBER_K][KYBER_N]) {
    uint16_t tempResultado[KYBER_K][KYBER_N] = {{0}};
    uint16_t tempMultiplicacao[KYBER_N] = {0}; 

    for (int i = 0; i < KYBER_K; ++i) {
        for (int k = 0; k < KYBER_K; ++k) {            
            multiplicaNTT(A[k][i], r_hat[k], tempMultiplicacao); 
            invntt(tempMultiplicacao); 

            // Soma os resultados ao tempResultado[i]
            for (int n = 0; n < KYBER_N; ++n) {
                tempResultado[i][n] = (tempResultado[i][n] + tempMultiplicacao[n]) % KYBER_Q;
            }
        }
    }

    // Soma e1 ao resultado para obter u
    for (int i = 0; i < KYBER_K; ++i) {
        for (int n = 0; n < KYBER_N; ++n) {
            u[i][n] = (tempResultado[i][n] + e1[i][n]) % KYBER_Q;
        }
    }
    
}


void calculaV(uint16_t t_hat[KYBER_K][KYBER_N], uint16_t r_vector[KYBER_K][KYBER_N], uint16_t e2[KYBER_N], uint16_t mu[KYBER_N], uint16_t v[KYBER_N]) {
    uint16_t temp[KYBER_N] = {0};
    uint16_t v_ntt[KYBER_N] = {0}; // Temporariamente armazena o resultado da soma NTT antes da inversa.

    for (int i = 0; i < KYBER_K; i++) {
        multiplicaNTT(t_hat[i], r_vector[i], temp);

        // Acumula o resultado em v_ntt
        for (int j = 0; j < KYBER_N; j++) {
            v_ntt[j] = (v_ntt[j] + temp[j]) % KYBER_Q;
        }
    }

    invntt(v_ntt); // Aplica NTT inversa uma vez, depois de acumular todos os resultados em v_ntt.

    // Adiciona e2 e mu ao resultado da NTT inversa
    for (int i = 0; i < KYBER_N; i++) {        
        v[i] = (v_ntt[i] + e2[i] + mu[i]) % KYBER_Q;
    }
}



void decompressMu(const uint8_t *m, uint16_t mu[KYBER_N]) {
    
    uint16_t m_decoded[KYBER_N]; // Buffer temporário para o resultado decodificado
    
    // Decodifica 'm' para um array de inteiros com d=1
    
    byteDecode(m, m_decoded, 1); // byteDecode1 realiza a decodificação com d=1

    // Decompressão de cada elemento decodificado em 'mu' com d=1
    for (int i = 0; i < KYBER_N; i++) {
        mu[i] = decompress_d(m_decoded[i], 1);    
    }
}

void generateRandomVectors(const uint8_t *r, uint16_t r_vector[KYBER_K][KYBER_N], uint16_t e1[KYBER_K][KYBER_N], uint16_t e2[KYBER_N], uint8_t N) {
    unsigned char prfOutput[64 * KYBER_ETA1]; // Buffer para a saída da PRF

    // Geração de r_vector
    for (int i = 0; i < KYBER_K; i++) {
        PRF(KYBER_ETA1, r, N++, prfOutput);
        samplePolyCBD(prfOutput, r_vector[i], KYBER_ETA1);
    }

    // Geração de e1
    for (int i = 0; i < KYBER_K; i++) {
        PRF(KYBER_ETA2, r, N++, prfOutput);
        samplePolyCBD(prfOutput, e1[i], KYBER_ETA2);
    }

    // Geração de e2
    PRF(KYBER_ETA2, r, N, prfOutput);
    samplePolyCBD(prfOutput, e2, KYBER_ETA2);
}

void compressAndEncode(const uint16_t u[KYBER_K][KYBER_N], const uint16_t v[KYBER_N], uint8_t c1[], uint8_t c2[]) {
    // Compressão e codificação de u para c1
    for (int i = 0; i < KYBER_K; i++) {
        uint16_t compressedU[KYBER_N];
        for (int j = 0; j < KYBER_N; j++) {
            compressedU[j] = compress_d(u[i][j], KYBER_DU);
        }
        byteEncode(compressedU, c1 + i * (KYBER_N * KYBER_DU / 8), KYBER_DU);
    }

    // Compressão e codificação de v para c2
    uint16_t compressedV[KYBER_N];
    for (int i = 0; i < KYBER_N; i++) {
        compressedV[i] = compress_d(v[i], KYBER_DV);
    }
    byteEncode(compressedV, c2, KYBER_DV);
}

void exibeVetorPolinomios(uint16_t vetor[2][256], char* nomeVetor){
    printf("\n Vetor %s : ", nomeVetor);
    for (int i = 0; i < KYBER_K; i++)
    {
        for (int j = 0; j < KYBER_N; j++)
        {
            printf("%d ,",vetor[i][j]);
        }
        printf("\n");
    }
    
}

void verificaCalculoT(uint16_t t1[2][256],uint16_t t2[2][256]) {
     if((memcmp(t1[0],t2[0],sizeof(t1[0]))==0) && (memcmp(t1[1],t2[1],sizeof(t1[1]))==0)) {
        printf("\n\n Vetor t foi calculado corretamente!!!!");
    }
    else {
        printf("\n\n Falha no cálculo do vetor t");
    }
}

void exibeChaves(chavesPKE chaves) {
    printf("Chaves \n chave pública : ");
    for (int i = 0; i < sizeof(chaves.ek)/sizeof(chaves.ek[0]); i++)
    {
        printf("%02x", chaves.ek[i]);
    }
    printf("\n \nchave privada : ");
    for (int i = 0; i < sizeof(chaves.dk)/sizeof(chaves.dk[0]); i++)
    {
        printf("%02x", chaves.dk[i]);
    }
}

void pkeEncrypt(const uint8_t *ekPKE, const uint8_t *m, const uint8_t *r, uint8_t *c) {
    uint16_t t_hat[KYBER_K][KYBER_N] = {{0}};

    uint16_t A[KYBER_K][KYBER_K][KYBER_N] =  {
    {
        {3148, 1442, 2340, 1715, 2444, 1410, 329, 2225, 752, 2583, 2104, 1713, 2548, 1790, 2306, 2268, 1866, 1936, 1958, 809, 3074, 2748, 1977, 1971, 463, 425, 2794, 402, 1901, 3074, 1274, 2807, 435, 792, 2415, 2727, 2619, 3022, 575, 941, 1943, 1335, 1414, 2705, 1135, 1045, 880, 329, 1346, 2282, 1180, 2015, 2903, 1137, 189, 1339, 3101, 386, 3173, 761, 2788, 3312, 2257, 910, 596, 1466, 1445, 2713, 1611, 2055, 205, 2902, 521, 1624, 1717, 1030, 3014, 917, 147, 2613, 2630, 1539, 1847, 2171, 2587, 1729, 573, 869, 1054, 189, 3162, 2331, 2859, 1539, 3196, 549, 536, 637, 3146, 2823, 941, 2630, 170, 740, 3188, 883, 1892, 2817, 2387, 2331, 1246, 508, 1944, 1467, 1412, 1678, 823, 3015, 1036, 3160, 1791, 1105, 871, 1673, 625, 500, 677, 220, 824, 3192, 747, 2621, 2373, 2209, 676, 1020, 2765, 1159, 3328, 1106, 2047, 572, 1549, 405, 2809, 640, 673, 2619, 1464, 838, 1063, 1855, 1453, 428, 797, 629, 1081, 2055, 2461, 2844, 672, 2086, 2684, 295, 878, 196, 3034, 1273, 1116, 1109, 186, 885, 2579, 2273, 630, 223, 3218, 1696, 303, 2943, 458, 2535, 703, 2504, 1701, 3056, 1218, 898, 3177, 2261, 944, 2828, 1940, 2080, 843, 1546, 3289, 1805, 1004, 2652, 1286, 853, 1339, 2260, 1507, 2577, 1028, 2758, 3300, 1779, 2645, 2253, 815, 311, 1792, 3264, 1048, 970, 1445, 2811, 481, 1461, 2528, 190, 1076, 1296, 823, 2220, 2423, 1036, 2029, 2404, 2971, 639, 2408, 2070, 383, 1102, 1274, 2709, 612, 2289, 125, 2053, 2445, 274, 400, 870, 1063, 1947, 534, 861, 2151, 1813, 876, 1387}, 
        {2820, 3002, 10, 211, 2606, 1584, 2557, 697, 1954, 332, 3220, 780, 46, 765, 956, 3230, 1547, 745, 650, 1880, 1940, 2651, 2163, 708, 2138, 2010, 3157, 2654, 1598, 610, 3297, 2109, 2371, 2216, 2333, 2472, 937, 1329, 2006, 1411, 2730, 338, 2143, 1927, 2036, 2539, 2323, 647, 2540, 2259, 2276, 2518, 1726, 1277, 1035, 2435, 2515, 2438, 534, 2214, 779, 3215, 579, 751, 368, 945, 1345, 1156, 533, 2065, 978, 1483, 1795, 1557, 445, 1916, 1106, 198, 14, 1614, 1447, 83, 1934, 2882, 2304, 3133, 2413, 397, 2324, 2349, 2242, 1483, 2126, 3284, 271, 265, 2471, 3158, 778, 198, 2629, 2141, 1129, 48, 2350, 3046, 2066, 2773, 226, 1905, 2305, 2023, 1557, 2268, 318, 2340, 2285, 1215, 151, 882, 748, 3192, 3132, 3195, 1120, 1325, 3089, 2879, 773, 541, 1759, 1402, 2962, 1271, 616, 266, 1081, 67, 1914, 447, 2470, 2831, 350, 1506, 1674, 2972, 1524, 2353, 448, 1982, 1223, 1414, 1599, 2035, 971, 40, 3149, 2113, 1744, 2611, 2824, 3323, 1727, 1984, 1428, 2831, 722, 3204, 2038, 2966, 707, 253, 1386, 1885, 1770, 620, 1181, 2470, 2435, 2562, 409, 2479, 3006, 2353, 1686, 3256, 1933, 2749, 2355, 251, 2230, 2888, 1452, 2270, 2047, 1814, 2854, 1225, 1445, 2443, 360, 1629, 2620, 1135, 2699, 3297, 524, 3064, 19, 190, 2544, 1474, 3072, 1575, 630, 495, 2111, 2025, 239, 1174, 3097, 1722, 3141, 3223, 2205, 2173, 3, 737, 391, 1882, 742, 315, 3200, 3006, 2391, 196, 257, 3115, 885, 2022, 2653, 0, 2551, 2744, 1800, 2163, 3117, 1487, 2222, 2908, 2586, 1493, 828, 145, 824, 1586}
    }, 
    {
        {973, 1414, 1565, 1602, 1348, 508, 2422, 2672, 966, 665, 2003, 2108, 3061, 767, 941, 1238, 1854, 1970, 1949, 883, 1067, 2860, 2366, 2442, 2729, 2489, 970, 5, 2992, 467, 1709, 1937, 246, 700, 802, 2083, 571, 2171, 3299, 2145, 2332, 2902, 1975, 3139, 1872, 1602, 955, 950, 935, 3006, 1032, 653, 67, 1469, 2370, 2326, 158, 1347, 1366, 1514, 2632, 2043, 2417, 1326, 3160, 2224, 1586, 2355, 1263, 1853, 468, 524, 963, 2192, 2303, 822, 749, 541, 2674, 1047, 2656, 3315, 1918, 3057, 1339, 1218, 2930, 1342, 2531, 1181, 299, 260, 2871, 556, 2651, 2927, 2803, 1632, 1447, 851, 2041, 1903, 1939, 1711, 695, 3124, 1704, 2899, 1514, 1680, 352, 1372, 196, 1407, 713, 1125, 1196, 2356, 2446, 1181, 1279, 2058, 669, 2012, 1579, 642, 228, 1783, 3155, 903, 668, 2766, 105, 1488, 1990, 108, 1375, 2015, 902, 2709, 993, 1529, 369, 122, 878, 3286, 829, 2935, 55, 3040, 148, 3092, 2096, 3007, 440, 2016, 1008, 236, 2990, 1927, 682, 1211, 1950, 1167, 1968, 1675, 2650, 1757, 2361, 1409, 1166, 1591, 2032, 109, 80, 303, 301, 185, 255, 2520, 1874, 217, 1829, 910, 652, 3127, 2805, 3277, 273, 123, 619, 3036, 2674, 948, 208, 2047, 2219, 1872, 2296, 3024, 1780, 122, 2557, 2607, 3050, 2924, 1301, 1923, 2558, 2978, 1775, 661, 2557, 1467, 1754, 1905, 2936, 392, 2707, 2225, 372, 1841, 3107, 1380, 219, 2496, 756, 3183, 1989, 1054, 1125, 368, 1248, 101, 3218, 1361, 588, 2569, 1976, 2444, 2318, 2854, 2617, 2560, 840, 1210, 1352, 2469, 1987, 3297, 1743, 669, 3219, 613, 2079, 2706}, 
        {335, 1520, 2696, 735, 1858, 382, 2680, 1945, 2102, 8, 1684, 1681, 2763, 2670, 514, 3083, 1810, 1417, 437, 3144, 2296, 3172, 1536, 385, 63, 1964, 2831, 192, 3078, 200, 1157, 306, 2853, 820, 1351, 2649, 2330, 1415, 2640, 1434, 2825, 1644, 2644, 2529, 2478, 2631, 1726, 997, 3176, 1089, 2357, 84, 852, 1860, 2341, 280, 1966, 2938, 2600, 1411, 978, 35, 827, 1753, 328, 3325, 2467, 2466, 3250, 1027, 781, 1497, 568, 2769, 2538, 579, 120, 572, 2327, 573, 2030, 2286, 2761, 2713, 2904, 2321, 1860, 1547, 1466, 587, 14, 1735, 2714, 786, 1799, 890, 1516, 2258, 654, 2439, 528, 1425, 886, 1218, 2042, 2141, 981, 468, 2655, 2298, 758, 905, 73, 2548, 1366, 2902, 3113, 3280, 2826, 2384, 2617, 2092, 2967, 2994, 277, 2060, 664, 2363, 863, 841, 371, 1761, 2733, 1519, 2545, 3257, 618, 2848, 1643, 2616, 2138, 110, 2069, 2795, 1527, 1286, 77, 663, 3296, 2054, 54, 3323, 2888, 2308, 2734, 541, 1039, 1324, 2082, 39, 1557, 408, 2630, 1645, 679, 722, 1963, 2267, 2712, 3283, 882, 707, 1095, 804, 561, 3308, 665, 1794, 879, 1249, 2969, 399, 1871, 2924, 3033, 843, 1157, 2439, 851, 1766, 787, 2644, 1173, 885, 747, 867, 997, 1955, 791, 2082, 3162, 85, 1445, 1512, 1672, 1244, 2871, 1438, 1244, 2137, 3286, 3006, 2411, 757, 2772, 2119, 1503, 1431, 246, 2961, 1677, 3189, 17, 735, 2705, 833, 669, 1166, 703, 2691, 3101, 1603, 749, 2930, 880, 3295, 1823, 2332, 1197, 2774, 2695, 474, 2015, 1683, 3191, 731, 2523, 397, 3003, 832, 1379, 1485, 1672, 2376, 3159, 802}
    }
    };

    uint16_t r_vector[KYBER_K][KYBER_N] = {
        {1, 2, 1, 0, 0, 0, 3328, 0, 0, 1, 3328, 3327, 3328, 3328, 1, 3328, 3328, 1, 1, 0, 0, 0, 2, 0, 3327, 0, 3328, 0, 0, 2, 3328, 3328, 3327, 2, 0, 1, 3328, 3328, 0, 1, 1, 1, 0, 0, 2, 1, 1, 1, 1, 3, 0, 3327, 1, 0, 0, 0, 2, 3328, 0, 3328, 1, 2, 3328, 1, 2, 0, 1, 3328, 1, 3328, 0, 0, 1, 2, 3328, 1, 0, 0, 0, 1, 3328, 2, 1, 1, 2, 0, 1, 3328, 3328, 0, 0, 3327, 1, 1, 3327, 1, 3328, 2, 0, 2, 3328, 0, 0, 2, 3327, 2, 0, 1, 1, 1, 0, 0, 3328, 1, 0, 1, 3328, 1, 0, 1, 0, 1, 1, 1, 1, 2, 0, 3328, 0, 1, 1, 3327, 0, 3328, 3328, 1, 1, 1, 0, 0, 3328, 0, 0, 3328, 3328, 0, 3328, 3328, 3327, 0, 0, 3328, 3327, 2, 3328, 3327, 1, 1, 1, 3328, 1, 0, 3327, 3328, 2, 0, 1, 0, 1, 0, 0, 0, 3327, 1, 3328, 3327, 0, 3328, 2, 0, 0, 3328, 1, 3328, 1, 3328, 3328, 3327, 1, 3327, 3328, 1, 3328, 1, 3328, 0, 3328, 3328, 3328, 3328, 1, 0, 0, 3328, 0, 2, 0, 1, 3327, 3327, 3328, 0, 0, 1, 3327, 3328, 3327, 0, 3327, 1, 3328, 0, 1, 3328, 3, 3328, 2, 3328, 1, 3328, 2, 0, 1, 2, 3328, 3327, 2, 1, 3, 2, 3328, 0, 0, 1, 3326, 3327, 0, 0, 0, 0, 0, 3328, 0, 2, 1, 1},
        {0, 0, 2, 0, 1, 2, 1, 1, 3328, 0, 3, 1, 1, 3326, 3328, 3327, 3328, 3328, 0, 0, 3328, 3328, 0, 0, 1, 1, 0, 0, 0, 2, 0, 2, 3326, 3328, 1, 1, 1, 3327, 1, 0, 1, 0, 2, 0, 3328, 3328, 3327, 1, 3328, 1, 0, 0, 3328, 0, 0, 3327, 1, 1, 1, 0, 1, 2, 3328, 2, 2, 1, 2, 0, 3328, 1, 0, 2, 3328, 1, 1, 3327, 1, 0, 0, 1, 3328, 2, 0, 3327, 0, 1, 0, 3327, 3328, 1, 0, 3328, 1, 0, 3328, 3327, 3327, 0, 2, 3327, 0, 1, 3328, 1, 3328, 1, 3327, 0, 2, 3328, 1, 3327, 3328, 3328, 0, 2, 3328, 1, 0, 3328, 3328, 1, 1, 3328, 0, 3326, 0, 1, 1, 3328, 3328, 1, 1, 1, 2, 0, 3328, 3327, 2, 1, 3328, 1, 1, 1, 0, 1, 0, 3328, 3328, 1, 3328, 1, 0, 3327, 3328, 1, 2, 3327, 0, 3328, 3327, 0, 1, 3328, 2, 0, 0, 3328, 0, 3328, 0, 0, 0, 1, 3328, 1, 3328, 3328, 0, 3328, 1, 3328, 0, 3327, 0, 3328, 3328, 1, 2, 3328, 1, 0, 3328, 2, 3328, 1, 2, 3327, 2, 0, 0, 0, 0, 3328, 3328, 0, 3328, 1, 0, 3328, 1, 1, 1, 1, 3328, 0, 0, 0, 0, 3328, 3328, 0, 0, 1, 3326, 1, 1, 3327, 0, 1, 2, 3, 2, 0, 3328, 1, 3327, 3328, 0, 2, 1, 3327, 1, 1, 0, 3328, 1, 3327, 3328, 1, 0, 2, 2, 3328, 3327, 3328}
        };

    uint16_t e1[KYBER_K][KYBER_N] = {
        {0, 1, 1, 3328, 3328, 3328, 0, 1, 0, 1, 3328, 0, 2, 1, 0, 1, 1, 3328, 1, 0, 2, 0, 0, 3328, 0, 3328, 1, 3327, 3328, 2, 0, 0, 0, 0, 1, 0, 1, 3328, 3328, 2, 3328, 1, 1, 2, 0, 1, 0, 0, 0, 0, 3328, 1, 0, 3328, 0, 0, 1, 0, 1, 0, 0, 0, 1, 3327, 0, 1, 0, 3327, 2, 0, 2, 0, 1, 1, 1, 1, 3328, 1, 1, 0, 1, 1, 0, 3328, 0, 0, 0, 0, 0, 3327, 1, 0, 3328, 1, 0, 0, 3328, 3328, 0, 1, 3328, 3328, 1, 3328, 3328, 0, 3327, 1, 3328, 3328, 3328, 0, 3327, 2, 3328, 0, 0, 0, 0, 3328, 3328, 2, 3328, 2, 0, 3328, 0, 0, 1, 0, 2, 3328, 1, 0, 0, 1, 3327, 2, 0, 0, 3328, 0, 3328, 0, 3328, 3328, 3327, 3328, 1, 0, 3328, 0, 1, 2, 0, 3327, 1, 1, 0, 3328, 3328, 2, 3327, 0, 1, 3328, 0, 0, 3328, 0, 2, 0, 0, 3328, 3328, 0, 3328, 1, 0, 3328, 1, 3328, 3328, 3327, 1, 0, 3327, 1, 1, 0, 3328, 0, 3328, 3328, 3328, 3328, 1, 2, 3328, 1, 0, 0, 0, 0, 3328, 3328, 0, 3328, 2, 1, 2, 0, 0, 3328, 1, 2, 3328, 3328, 1, 0, 3328, 0, 1, 3328, 3328, 0, 1, 3328, 2, 0, 1, 3328, 0, 3328, 0, 0, 3328, 3328, 1, 1, 3328, 3328, 0, 0, 3328, 0, 1, 1, 3328, 0, 0, 3328, 3328, 1, 0, 3328},
        {1, 0, 0, 1, 1, 1, 3327, 0, 1, 3327, 0, 3328, 1, 1, 3328, 2, 3327, 3328, 3327, 3328, 3328, 3328, 0, 3327, 3328, 0, 1, 0, 3327, 1, 3328, 3328, 0, 1, 1, 0, 2, 1, 3328, 3328, 0, 3328, 1, 0, 0, 0, 0, 0, 1, 2, 0, 3328, 0, 3328, 0, 3328, 3327, 3328, 3328, 0, 0, 1, 3328, 0, 3328, 2, 1, 0, 0, 1, 3327, 0, 0, 1, 1, 3328, 0, 1, 0, 3328, 3328, 0, 1, 0, 0, 3328, 1, 0, 3327, 3327, 1, 0, 0, 0, 3328, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 3327, 1, 0, 0, 3328, 1, 2, 0, 1, 1, 2, 0, 3328, 3328, 0, 3328, 1, 3328, 0, 3327, 1, 1, 3328, 0, 3327, 0, 3328, 3327, 2, 0, 0, 0, 3328, 3328, 0, 3328, 1, 1, 3328, 1, 1, 3328, 3327, 3328, 0, 3328, 3327, 0, 1, 1, 3328, 1, 0, 1, 2, 1, 1, 1, 3328, 1, 1, 0, 3328, 0, 1, 0, 0, 1, 3328, 1, 1, 0, 0, 3328, 3328, 1, 3327, 3328, 0, 1, 2, 0, 3328, 0, 0, 0, 3328, 3328, 3328, 2, 3328, 1, 1, 3328, 1, 1, 3327, 0, 0, 0, 3328, 1, 1, 3328, 0, 0, 3327, 3328, 0, 3328, 2, 0, 0, 0, 2, 0, 0, 1, 2, 1, 2, 2, 3328, 0, 1, 1, 0, 1, 2, 0, 0, 1, 1, 1, 0, 1, 0, 0, 3328, 3328, 1, 1, 3328, 0, 2, 0, 0, 2, 0, 1, 0}
        };

    uint16_t e2[KYBER_N] = {0, 0, 1, 3328, 3328, 0, 3328, 0, 0, 1, 3327, 1, 0, 3328, 3328, 0, 3328, 2, 3328, 1, 1, 3327, 1, 3328, 0, 2, 3328, 1, 3327, 0, 0, 0, 3328, 1, 2, 0, 0, 2, 0, 2, 0, 3328, 1, 3327, 0, 3328, 0, 2, 2, 3328, 2, 1, 0, 0, 1, 0, 1, 3328, 3328, 0, 0, 0, 0, 1, 0, 3327, 3328, 1, 0, 0, 3328, 3328, 0, 1, 0, 1, 3328, 3328, 0, 0, 3328, 3328, 2, 3328, 1, 3327, 3328, 3328, 1, 2, 3328, 1, 0, 0, 3328, 1, 3327, 3328, 0, 0, 0, 1, 3328, 3328, 0, 1, 0, 0, 0, 0, 0, 1, 0, 3327, 0, 3328, 0, 3328, 0, 1, 0, 0, 3327, 3327, 3328, 3328, 0, 1, 3328, 1, 0, 1, 0, 0, 0, 0, 3328, 0, 1, 3328, 1, 0, 3328, 0, 3328, 0, 1, 1, 2, 0, 1, 0, 3328, 0, 3327, 0, 3328, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 2, 3328, 3327, 0, 2, 3328, 3327, 1, 2, 1, 1, 0, 0, 0, 3328, 0, 1, 3327, 3328, 3327, 3327, 3328, 1, 2, 1, 1, 0, 0, 1, 3328, 3328, 3328, 1, 1, 3328, 0, 1, 0, 1, 3328, 3328, 3328, 3328, 0, 1, 0, 2, 2, 1, 3327, 1, 1, 1, 3328, 3327, 0, 2, 3328, 3328, 0, 2, 1, 1, 0, 0, 1, 3328, 3328, 0, 0, 0, 0, 3328, 3328, 1, 0, 3328, 3327, 0, 0, 3328, 3328, 1, 1, 3328, 1, 0, 3328, 1};

    uint16_t u[KYBER_K][KYBER_N] = {{0}};
    uint16_t v[KYBER_N] = {0};
    uint16_t a_hat[KYBER_N] = {0};
    uint8_t rho[32], c1[KYBER_K * KYBER_N * KYBER_DU / 8], c2[KYBER_N * KYBER_DV / 8];
    uint16_t mu[KYBER_N]; // Decodificar e descomprimir 'm' para 'mu'  
    unsigned char md[EVP_MAX_MD_SIZE];   // Vetor para armazenar o resultado de SHAKE128(ρ|i|j)  
    uint8_t N = 0;

       
    // Passo 2: ByteDecode do ekPKE para t_hat
    // 2.1 Calcula o tamanho do subarray baseado em KYBER_K
    int subarraySize = 384 * KYBER_K;

    // 2.2 Cria um buffer temporário para armazenar os 384*KYBER_K bytes de ekPKE
    uint8_t ekPKE_Subarray[subarraySize];

    // 2.3 Copia os primeiros 384*KYBER_K bytes de ekPKE para ekPKE_Subarray
    memcpy(ekPKE_Subarray, ekPKE, subarraySize);   

    // 2.4 Decodificando para t_hat com d=12
    uint8_t auxiliar[384];
    for (int i = 0; i < KYBER_K; i++)
    {
        if (i==0)
        {
            memcpy(auxiliar,ekPKE_Subarray, 384);  
            printf("Decodificando t_hat, i==0 no IF");
        }
        else {
            memcpy(auxiliar,ekPKE_Subarray + i* 384, 384);  
        }
                
        byteDecode(auxiliar, t_hat[i], 12);
    }

    
    // Passo 3: Extração de rho
    memcpy(rho, ekPKE + 384 * KYBER_K, 32);
    
    
    printf("\n ekpke: ");
    for (int i=384*KYBER_K; i<384*KYBER_K+32; i++) {
        printf("%02x ",ekPKE[i]);        
    }
    
    printf("\n rho: ");
    for (int i=0; i<32; i++) {     
        printf("%d ", rho[i]);
    }
/*
    // Passo 4-8: Geração da matriz A
    for (int i = 0; i < KYBER_K; i++) {
        unsigned char i_char = (unsigned char)i;    
        for (int j = 0; j < KYBER_K; j++) {       
           memset(md, 0, sizeof(md));              // Reseta o vetor md                  
           unsigned char j_char = (unsigned char)j;            
           XOF(rho, i_char, j_char, md);               
           memset(a_hat, 0, sizeof(a_hat));      // Reinicializa a_hat para garantir que seja único em cada iteração
           sampleNTT(md, a_hat);                // Preenche a_hat com os coeficientes NTT                                                        
           for (int k=0; k < KYBER_N; k++) {                         
                // Copia a_hat para a terceira dimensão da matriz A
                A[i][j][k] = a_hat[k];     
                printf("%d ", A[i][j][k]) ;             
           } 
           printf("\n\n");
        }
    }

    // Uso da função generateRandomVectors para gerar r_vector, e1, e2
    generateRandomVectors(r, r_vector, e1, e2, 0); // N inicializado como 0
    */

    // Passo 18: Aplicação de NTT a r
    // Aplicação de NTT a r_vector antes de computeU e computeV
    for (int i = 0; i < KYBER_K; i++) {
        ntt(r_vector[i]);
    }

    // Passo 19: Calcular u
    calculaU(A, r_vector, e1, u);

    // 20: µ ← Decompress1(ByteDecode1(m)))    
    decompressMu(m, mu);
    
    // 21: v ← NTT−1(t^⊺ ◦ rˆ) +e2 + µ
    calculaV(t_hat, r_vector, e2, mu, v);

    // Compressão e codificação de u e v para c1 e c2
    compressAndEncode(u, v, c1, c2);

    // 24: return c ← (c1∥c2)
    memcpy(c, c1, sizeof(c1)); // Copia 'c1' para 'c'
    memcpy(c + sizeof(c1), c2, sizeof(c2)); // Concatena 'c2' após 'c1' em 'c'

}

int main() {
    // Criando uma mensagem específica de 32 caracteres
    char mensagem_texto[] = "Esta mensagem tem exatamente 32b";
    uint8_t msg[32] = {0};
    unsigned char c[32*(KYBER_DU*KYBER_K+KYBER_DV)] = {0};
    uint8_t r[32] = {0x32, 0xa7, 0x9d, 0x88, 0x06, 0xea, 0xc0, 0x37, 0x29, 0xc9, 0xbc, 0x36, 0x3c, 0x0f, 0x64, 0xdf, 
                     0xf8, 0xda, 0x32, 0x60, 0xa1, 0x7a, 0xf3, 0xc5, 0x14, 0xb0, 0xe0, 0xfa, 0x03, 0x67, 0x0c, 0x56};
    
    // Imprimindo a mensagem
    printf("msg: ");
    // Para imprimir cada caractere como seu valor de byte, use um loop
    for(int i = 0; mensagem_texto[i] != '\0'; i++) {
        printf("%02x ", (unsigned char)mensagem_texto[i]);  // Imprime cada byte em hexadecimal
        msg[i] = (uint8_t)mensagem_texto[i];
    }

    uint8_t c_linha[32*(KYBER_DU*KYBER_K+KYBER_DV)] = {0xf5, 0x4f, 0x8c, 0x0e, 0xf5, 0x2e, 0xf3, 0xb7, 0x79, 0x0c, 0x88, 0x59, 0x64, 0x58, 0x33, 0xaa, 0xb5, 0xdd, 0xf6, 0x88, 0xb4, 0xce, 0x30, 0xf0, 0xdd, 0xc2, 0x16, 0x6c, 0x1b, 0xf5, 0x02, 0xed, 0x11, 0x44, 0x0f, 0x95, 0x51, 0x7d, 0xbc, 0x64, 0x46, 0x77, 0x6f, 0x01, 0x71, 0x7e, 0xfb, 0x43, 0x22, 0xd5, 0x6d, 0x9d, 0x72, 0x62, 0x39, 0x76, 0x61, 0x02, 0x1e, 0xd5, 0x55, 0xbd, 0x8c, 0xcd, 0xfd, 0xcb, 0xba, 0xf7, 0x5c, 0x44, 0x75, 0x16, 0x95, 0xc9, 0xd9, 0xec, 0x9d, 0x96, 0x8e, 0x0c, 0xeb, 0xb7, 0x73, 0x89, 0xa5, 0x6d, 0x45, 0x38, 0xe1, 0xc3, 0x7e, 0xae, 0x6d, 0x4f, 0x81, 0xaa, 0x25, 0x2d, 0xaf, 0xb8, 0x45, 0x31, 0x1f, 0xc8, 0x0a, 0x4e, 0x18, 0x80, 0x69, 0x8b, 0x93, 0xda, 0x57, 0xe1, 0x72, 0xf7, 0xc5, 0x5f, 0x49, 0x88, 0x4d, 0x73, 0x7f, 0x23, 0x59, 0x96, 0x2b, 0x53, 0x75, 0xa4, 0xbd, 0x5f, 0x02, 0x60, 0xbd, 0x85, 0xe4, 0x55, 0xf8, 0x02, 0xf0, 0x39, 0xf9, 0x04, 0x6f, 0xa2, 0x49, 0xe5, 0x4b, 0x41, 0xfa, 0x51, 0x03, 0x17, 0x9b, 0xe5, 0x45, 0x4a, 0x9a, 0xe2, 0x2e, 0xfe, 0x4e, 0x6f, 0x4d, 0xb4, 0xd5, 0xb7, 0x7e, 0xc4, 0x7b, 0x28, 0xa6, 0xbd, 0x67, 0x80, 0xc1, 0x77, 0x3e, 0x35, 0x82, 0x1e, 0xfb, 0xb9, 0x1c, 0xaf, 0xf5, 0xfc, 0x6e, 0x9e, 0x9a, 0xb2, 0xc5, 0x01, 0x13, 0x04, 0x40, 0x60, 0xc3, 0x51, 0xd0, 0x6e, 0x87, 0xa7, 0x93, 0xd0, 0x82, 0xe8, 0x1e, 0xd9, 0xc7, 0x6c, 0x78, 0x51, 0xdd, 0x8c, 0x4c, 0x81, 0x4f, 0x6e, 0x15, 0xee, 0x3a, 0xec, 0x21, 0xc6, 0x94, 0xc5, 0x89, 0x73, 0x53, 0xdd, 0x33, 0xb9, 0x75, 0xc2, 0xdb, 0x02, 0xdd, 0xa8, 0xa4, 0x8e, 0x00, 0x46, 0x64, 0x7a, 0x9c, 0x44, 0xa0, 0x34, 0x24, 0x6b, 0xc8, 0xde, 0xfd, 0x0d, 0xd1, 0x5f, 0xb8, 0x0c, 0x45, 0xee, 0x97, 0x54, 0x6d, 0x76, 0x89, 0x5e, 0x74, 0xd0, 0x9a, 0x37, 0xda, 0x87, 0x5f, 0xca, 0x63, 0xf6, 0xb5, 0xa6, 0xc6, 0x09, 0x55, 0xd2, 0xc3, 0xce, 0xd2, 0xb0, 0x76, 0xa2, 0x61, 0xb1, 0xec, 0xee, 0x43, 0x89, 0xe9, 0xde, 0xc3, 0x44, 0x0e, 0xfd, 0x94, 0x8d, 0x27, 0xd2, 0x8b, 0x76, 0x85, 0x7f, 0xca, 0xa6, 0x64, 0xc7, 0x6a, 0x87, 0xa7, 0xad, 0x3e, 0x05, 0xe2, 0x5e, 0x51, 0x1f, 0xf6, 0x08, 0x42, 0x93, 0xb3, 0x79, 0xb9, 0x91, 0x81, 0xae, 0x47, 0x9b, 0xed, 0x52, 0x40, 0x88, 0x37, 0x16, 0xec, 0x3f, 0xd9, 0x79, 0x67, 0x33, 0xc9, 0xa3, 0x5c, 0x84, 0xcf, 0x43, 0x59, 0x70, 0x5d, 0xfb, 0x66, 0x9e, 0xcd, 0x85, 0x05, 0xcc, 0x33, 0xe2, 0xe9, 0x57, 0x94, 0xe7, 0xcd, 0x3a, 0xb8, 0xbd, 0xd5, 0x88, 0x9d, 0xad, 0x3b, 0xe2, 0x46, 0x50, 0x6e, 0x94, 0xd9, 0x28, 0x46, 0xb5, 0x64, 0x2a, 0x2b, 0xe9, 0x6d, 0x9f, 0x89, 0x83, 0x99, 0x11, 0xd8, 0x61, 0x8f, 0xfa, 0xfa, 0x52, 0x81, 0x7f, 0x4b, 0xe9, 0x6b, 0x15, 0x25, 0x02, 0xd4, 0x0e, 0x25, 0x4f, 0xd7, 0x3f, 0xc9, 0xa7, 0xcb, 0xe5, 0x3e, 0xf7, 0x88, 0x02, 0x62, 0xf4, 0xe4, 0xfe, 0x21, 0x9c, 0xbb, 0x90, 0x4c, 0x36, 0x58, 0xb9, 0x45, 0x5e, 0xe0, 0xed, 0xce, 0x88, 0xf7, 0x01, 0x53, 0x8a, 0xdf, 0x7b, 0x0e, 0xec, 0xfd, 0x35, 0x81, 0xde, 0x32, 0x2c, 0x6e, 0x62, 0x88, 0x4c, 0xfb, 0xcf, 0x8b, 0x58, 0xea, 0x0e, 0xd6, 0x26, 0x27, 0x37, 0xfa, 0x4d, 0x1f, 0xf2, 0xc6, 0xc0, 0x69, 0x5b, 0x85, 0x0c, 0x6f, 0x9d, 0xbb, 0x7e, 0xcf, 0x66, 0x53, 0x99, 0xfc, 0x26, 0x8d, 0xfb, 0x76, 0x48, 0xa2, 0x7f, 0xd6, 0xd4, 0x1c, 0x1e, 0x70, 0xe9, 0xa9, 0x5e, 0x76, 0xe4, 0x6b, 0x68, 0x48, 0xdc, 0x96, 0xfb, 0x1b, 0x03, 0xa3, 0x31, 0x72, 0xab, 0x57, 0x86, 0x12, 0x12, 0xf8, 0x1c, 0xb8, 0xda, 0x4b, 0xb5, 0xf4, 0x7d, 0x06, 0x15, 0xed, 0x8d, 0xa4, 0x8b, 0xfa, 0x14, 0xbe, 0x8e, 0xc8, 0x76, 0xfd, 0x40, 0x76, 0xeb, 0xb9, 0x99, 0x8e, 0x27, 0xf8, 0xb7, 0x71, 0xf4, 0x44, 0x4a, 0x0c, 0x90, 0x9c, 0xc1, 0x2a, 0xce, 0xf4, 0xab, 0x85, 0xcd, 0xa3, 0xbd, 0x3a, 0x1a, 0xaf, 0x07, 0xb0, 0x8d, 0xcf, 0x22, 0xdb, 0x0d, 0x45, 0xc6, 0x38, 0x6c, 0x59, 0x91, 0x87, 0x7e, 0xed, 0x65, 0x25, 0x09, 0xf7, 0x44, 0xa9, 0x32, 0x6a, 0x1e, 0x3a, 0x37, 0x2b, 0x4f, 0x6d, 0x91, 0x4c, 0xb8, 0x9b, 0x1c, 0x0d, 0x0a, 0x89, 0x7e, 0x23, 0xff, 0xee, 0x09, 0xfc, 0x52, 0xd0, 0x12, 0xd4, 0x42, 0x83, 0x1e, 0x7a, 0xc6, 0xf9, 0xb5, 0xdd, 0x86, 0xa7, 0xe8, 0xce, 0x80, 0x76, 0xbf, 0x8c, 0x4a, 0x19, 0xee, 0xd7, 0x76, 0x49, 0xb5, 0x27, 0x40, 0xab, 0x50, 0x6c, 0x51, 0x23, 0x56, 0x8d, 0xa0, 0xc8, 0x44, 0xdf, 0x13, 0x39, 0xcd, 0xb5, 0xc8, 0x2c, 0x35, 0x37, 0x99, 0xb3, 0xcc, 0x92, 0xec, 0x0f, 0x56, 0x4b, 0x20, 0x27, 0xaf, 0xa8, 0xba, 0x16, 0xcd, 0x49, 0x1a, 0x95, 0x13, 0x69, 0x46, 0x68, 0x1e, 0x3e, 0x89, 0x4b, 0x73, 0x37, 0xdf, 0xf5, 0x98, 0x28, 0xc7, 0x3d, 0xfc, 0x80, 0x5a, 0xac, 0x97, 0x6d, 0x04, 0xfb, 0x61, 0xb1, 0x59, 0x22, 0xb8, 0xad, 0xaf, 0x91, 0x9c, 0x3c, 0xed, 0xc9, 0xc4, 0xcf, 0x3c, 0x71, 0x13, 0xb3, 0xe0, 0x04, 0xec, 0xa3, 0x58, 0xa2, 0xff, 0xbf, 0xdd, 0x78, 0x14, 0xf6, 0x70, 0x8a, 0x7c, 0x7a, 0xc9, 0x31, 0xb0, 0x77, 0xbc, 0xfb, 0x3f, 0x46, 0xdf, 0x2e, 0x4c, 0x81, 0x09, 0xc6, 0xfb, 0x82, 0x77, 0x07, 0x61, 0x02, 0x42, 0xf2, 0x2e, 0x27, 0xe5, 0xc0, 0xaa};

    // Chave obtida com auxílio do código de referência do IETF
    uint8_t ekPKE[384*KYBER_K+32] = {
        0x75, 0x29, 0xad, 0xe0, 0x74, 0x89, 0x3c, 0xec, 0xcb, 0xc3, 0xfc, 0x52, 0xfc, 0x0b, 0xae, 0x3e, 
        0xf8, 0x5b, 0x78, 0xd3, 0x0b, 0xef, 0x16, 0xbb, 0xfc, 0x2a, 0x52, 0x66, 0xe4, 0x66, 0x2c, 0x53, 
        0xb3, 0x81, 0x30, 0x81, 0xf7, 0xbc, 0x41, 0xb3, 0x7a, 0xb0, 0x0b, 0xa8, 0xca, 0xeb, 0x5c, 0x43, 
        0xd7, 0xe3, 0x9b, 0x08, 0x36, 0x17, 0xa9, 0xc9, 0x22, 0x1a, 0x9b, 0x13, 0x72, 0x2a, 0x9e, 0x30, 
        0xa8, 0x4d, 0x09, 0xb1, 0x83, 0x76, 0xa4, 0x7d, 0x3e, 0xfb, 0x9d, 0xf2, 0x26, 0x00, 0x05, 0x55, 
        0xaa, 0x12, 0x33, 0x13, 0xb6, 0x36, 0x8f, 0xc4, 0xbb, 0x81, 0xea, 0x46, 0xb4, 0xe5, 0xc2, 0x1c, 
        0x99, 0xf9, 0x58, 0x52, 0x98, 0xa2, 0xda, 0xf4, 0x17, 0xdf, 0x16, 0x64, 0x61, 0xf1, 0xbc, 0xbd, 
        0x37, 0x10, 0xa2, 0x19, 0x19, 0xc3, 0xc7, 0x02, 0xc5, 0x48, 0x52, 0x96, 0xf8, 0xb8, 0xb7, 0xb4, 
        0x66, 0xa2, 0x06, 0x10, 0x9c, 0x56, 0x8b, 0x1d, 0x99, 0xc7, 0x58, 0x52, 0x9e, 0xd7, 0xb2, 0x89, 
        0xe6, 0x95, 0x08, 0xd2, 0x51, 0xa4, 0x1b, 0x30, 0xb1, 0x20, 0xc6, 0x86, 0xae, 0xf5, 0x34, 0x53, 
        0xe6, 0x45, 0xbb, 0x65, 0x34, 0x94, 0xc0, 0x42, 0xbc, 0xc6, 0x7a, 0xc7, 0x05, 0x85, 0x5f, 0x64, 
        0x5c, 0x3d, 0x63, 0x5a, 0x1e, 0x52, 0x59, 0x31, 0x32, 0x7f, 0xcb, 0x0a, 0x45, 0x80, 0x01, 0x96, 
        0x0d, 0x8c, 0x98, 0xfa, 0x36, 0x3a, 0x88, 0xa1, 0xa6, 0x40, 0xac, 0xc6, 0x35, 0x24, 0x7b, 0x8e, 
        0x3b, 0x7b, 0xde, 0x45, 0x75, 0x17, 0x19, 0x1b, 0xc7, 0x34, 0x6e, 0xb2, 0x32, 0x9e, 0x22, 0x59, 
        0x8b, 0xe7, 0xf2, 0xb4, 0x57, 0x10, 0x65, 0xf7, 0x06, 0x0b, 0xa8, 0x21, 0x20, 0xd7, 0x46, 0x00, 
        0x75, 0xd0, 0x49, 0x63, 0x7b, 0x30, 0x5b, 0x82, 0xb5, 0x8a, 0x54, 0x47, 0x2a, 0xe4, 0x1a, 0xda, 
        0x0c, 0xb4, 0xbd, 0x1a, 0x2e, 0x80, 0xa5, 0x9d, 0xfb, 0x30, 0x91, 0x17, 0x84, 0x3d, 0x00,
        0x28, 0xcc, 0x64, 0xc4, 0xb1, 0xe0, 0x59, 0x66, 0xfd, 0x5b, 0x88, 0x4e, 0xab, 0xc2, 0x25, 0xb8,
        0x9f, 0xd7, 0xbb, 0x03, 0xe7, 0x72, 0x70, 0x98, 0xe8, 0xc4, 0xfa, 0x65, 0xb3, 0x5a, 0x39, 0x04,
        0x49, 0x17, 0xad, 0xa7, 0xa6, 0xa2, 0xf0, 0x33, 0x88, 0x35, 0xf6, 0x80, 0xf9, 0x5b, 0xb3, 0x92,
        0x30, 0x46, 0x7d, 0x09, 0x2f, 0x80, 0x71, 0x6e, 0xfb, 0x6c, 0x72, 0x83, 0x28, 0x15, 0xdd, 0x86,
        0x96, 0x08, 0xe8, 0x7a, 0xc6, 0x22, 0x48, 0x80, 0xa2, 0x3e, 0x1e, 0x18, 0x49, 0xab, 0xea, 0x2f,
        0x1b, 0x97, 0x1d, 0xd9, 0x11, 0x4b, 0xe1, 0xc0, 0x02, 0x4b, 0x73, 0x77, 0xba, 0x82, 0x8b, 0xcc,
        0x79, 0x71, 0x6d, 0xb8, 0xc2, 0x97, 0x74, 0x1c, 0x13, 0x72, 0xb1, 0x9b, 0xa5, 0x9f, 0x59, 0x5a,
        0x44, 0x38, 0xe0, 0xc7, 0x84, 0xdc, 0x18, 0xaa, 0xac, 0x64, 0x0d, 0x81, 0x02, 0xc5, 0xba, 0x6b,
        0x7f, 0x59, 0xb1, 0x9e, 0xb5, 0x03, 0x5e, 0x06, 0x4f, 0xcf, 0xec, 0xc6, 0x09, 0x75, 0x23, 0x4b,
        0xa2, 0x90, 0x73, 0xaa, 0xb8, 0xee, 0x90, 0x61, 0x20, 0x1c, 0x0b, 0xf2, 0xe3, 0x8d, 0x8d, 0xa5,
        0x94, 0x98, 0x20, 0xca, 0xf8, 0x23, 0x42, 0x36, 0x37, 0x00, 0x02, 0x0a, 0x35, 0x9a, 0x1a, 0xba,
        0xf9, 0x83, 0x53, 0x73, 0x68, 0x14, 0x66, 0xe5, 0x08, 0x4b, 0x3a, 0xb0, 0xe8, 0x25, 0xa2, 0xa4,
        0x4a, 0xac, 0xe3, 0x96, 0x2e, 0xa2, 0x5a, 0x84, 0x25, 0xf0, 0x4d, 0xb6, 0xb6, 0x5b, 0xf4, 0xb6,
        0x2e, 0x2e, 0xbc, 0x83, 0xdd, 0xa0, 0xc3, 0x77, 0x29, 0x15, 0x9c, 0x1c, 0x6d, 0x6a, 0x3c, 0x56,
        0xf3, 0x87, 0x7d, 0xd1, 0x4a, 0x29, 0x9c, 0xe2, 0x6d, 0x2f, 0xa5, 0x7a, 0x13, 0x1a, 0x50, 0x7a, 
        0x61, 0x29, 0x85, 0xda, 0x06, 0xd2, 0x21, 0x64, 0x8f, 0x18, 0x1b, 0xb6, 0xcb, 0xaf, 0xa8, 0x0a, 
        0x6f, 0x95, 0xac, 0x82, 0xc4, 0xbc, 0x67, 0xdf, 0x64, 0xbf, 0xcf, 0x32, 0x80, 0x3e, 0xa1, 0x72, 
        0xeb, 0x51, 0x25, 0xe3, 0x54, 0x9e, 0x48, 0x15, 0x2c, 0x5d, 0x25, 0xa5, 0x8f, 0x64, 0xb7, 0xb1, 
        0xc1, 0xa1, 0xd1, 0xca, 0x53, 0x89, 0x21, 0x28, 0xa2, 0x40, 0x74, 0xd8, 0xd9, 0x0f, 0xcd, 0x33, 
        0xa6, 0x4e, 0x05, 0xcb, 0x19, 0xe1, 0xad, 0xf6, 0xb4, 0x84, 0xdd, 0x05, 0x60, 0xf0, 0x78, 0xbd, 
        0x6f, 0x74, 0x42, 0xe8, 0x44, 0x17, 0x9f, 0xd9, 0x3c, 0x77, 0xc2, 0x43, 0xea, 0xfa, 0x2a, 0x35, 
        0x40, 0xbe, 0x28, 0x73, 0x32, 0xbd, 0x01, 0x56, 0x82, 0x20, 0x9a, 0xd2, 0x07, 0x47, 0xae, 0x80, 
        0x46, 0xaa, 0x11, 0x82, 0x72, 0x22, 0xce, 0x91, 0x45, 0x3a, 0x5f, 0xbc, 0xa5, 0x7c, 0xd5, 0x1a, 
        0x83, 0x44, 0x6b, 0x60, 0xec, 0x9c, 0x1f, 0x7c, 0x28, 0xd4, 0xc3, 0x4c, 0xd0, 0x68, 0x0b, 0xfc, 
        0xc5, 0x55, 0xd2, 0x58, 0x51, 0x4a, 0x88, 0x09, 0x1b, 0xf3, 0x8e, 0x17, 0x32, 0x68, 0xdf, 0x17, 
        0x5f, 0x0d, 0xa9, 0x36, 0x32, 0x9a, 0xa8, 0xc1, 0x24, 0xb3, 0x3c, 0x89, 0x8e, 0x64, 0xda, 0x1b, 
        0x61, 0x5c, 0xcf, 0xc2, 0x69, 0x5f, 0x77, 0x99, 0x65, 0xcc, 0xe2, 0x6f, 0xe2, 0x22, 0xc4, 0x79, 
        0x49, 0xc0, 0x26, 0x08, 0x23, 0xf3, 0xf9, 0xcb, 0x2e, 0x09, 0x15, 0xdf, 0x66, 0x7b, 0x39, 0x61, 
        0x6c, 0xce, 0xe6, 0x50, 0x57, 0xe8, 0x20, 0xdc, 0x4c, 0x64, 0x37, 0xfb, 0x5c, 0x97, 0xf4, 0xa3, 
        0xbf, 0x56, 0x46, 0x74, 0xc5, 0xa4, 0x95, 0x50, 0xcb, 0x45, 0x33, 0x92, 0x97, 0x19, 0xa2, 0x30, 
        0x41, 0x3e, 0xd7, 0xd2, 0x1f, 0xf9, 0x82, 0xb2, 0x16, 0xf3, 0x69, 0x5e, 0x55, 0x90, 0x13, 0x83, 
        0xa4, 0xe2, 0xd5, 0x92, 0xde, 0xdb, 0xf1, 0x1e, 0x15, 0xe8, 0xec, 0x5b, 0xc5, 0x9c, 0x3f, 0xd9, 
        0xf7, 0xd3, 0x1b, 0x76, 0x72, 0x62, 0xc5, 0x06, 0x71, 0x84, 0x1a, 0x93, 0x81, 0x7c, 0x74, 0xc1, 0xab
        };

    pkeEncrypt(ekPKE, msg, r, c);
    printf("\n\n Texto Cifrado \n c =");

    for (int j = 0; j < 32*(KYBER_DU*KYBER_K+KYBER_DV); j++)
    {
        printf("%02x ,",c[j]);
    }
    printf("\n");

    if(memcmp(c_linha,c,sizeof(c_linha)) == 0) {
        printf("\n SUCESSO!!! \n O texto cifrado corresponde ao gerado pela implementação do IETF");
    }
    else {
        printf("\n Erro! \n textos cifrados não correspondem");
    }
}
